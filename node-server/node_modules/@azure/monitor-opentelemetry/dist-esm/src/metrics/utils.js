// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { SemanticAttributes, SemanticResourceAttributes, } from "@opentelemetry/semantic-conventions";
import { StandardMetricIds, StandardMetricPropertyNames, } from "./types";
export function getRequestDimensions(span) {
    const dimensions = getBaseDimensions(span.resource);
    dimensions.metricId = StandardMetricIds.REQUEST_DURATION;
    const statusCode = String(span.attributes["http.status_code"]);
    dimensions.requestResultCode = statusCode;
    dimensions.requestSuccess = statusCode === "200" ? "True" : "False";
    if (isSyntheticLoad(span)) {
        dimensions.operationSynthetic = "True";
    }
    return convertDimensions(dimensions);
}
export function getDependencyDimensions(span) {
    const dimensions = getBaseDimensions(span.resource);
    dimensions.metricId = StandardMetricIds.DEPENDENCIES_DURATION;
    const statusCode = String(span.attributes["http.status_code"]);
    dimensions.dependencyTarget = getDependencyTarget(span.attributes);
    dimensions.dependencyResultCode = statusCode;
    dimensions.dependencyType = "http";
    dimensions.dependencySuccess = statusCode === "200" ? "True" : "False";
    if (isSyntheticLoad(span)) {
        dimensions.operationSynthetic = "True";
    }
    return convertDimensions(dimensions);
}
export function getExceptionDimensions(resource) {
    const dimensions = getBaseDimensions(resource);
    dimensions.metricId = StandardMetricIds.EXCEPTIONS_COUNT;
    return dimensions;
}
export function getTraceDimensions(resource) {
    const dimensions = getBaseDimensions(resource);
    dimensions.metricId = StandardMetricIds.TRACES_COUNT;
    return dimensions;
}
export function getBaseDimensions(resource) {
    const dimensions = {};
    dimensions.IsAutocollected = "True";
    if (resource) {
        const spanResourceAttributes = resource.attributes;
        const serviceName = spanResourceAttributes[SemanticResourceAttributes.SERVICE_NAME];
        const serviceNamespace = spanResourceAttributes[SemanticResourceAttributes.SERVICE_NAMESPACE];
        if (serviceName) {
            if (serviceNamespace) {
                dimensions.cloudRoleName = `${serviceNamespace}.${serviceName}`;
            }
            else {
                dimensions.cloudRoleName = String(serviceName);
            }
        }
        const serviceInstanceId = spanResourceAttributes[SemanticResourceAttributes.SERVICE_INSTANCE_ID];
        dimensions.cloudRoleInstance = String(serviceInstanceId);
    }
    return dimensions;
}
export function getDependencyTarget(attributes) {
    if (!attributes) {
        return "";
    }
    const peerService = attributes[SemanticAttributes.PEER_SERVICE];
    const httpHost = attributes[SemanticAttributes.HTTP_HOST];
    const httpUrl = attributes[SemanticAttributes.HTTP_URL];
    const netPeerName = attributes[SemanticAttributes.NET_PEER_NAME];
    const netPeerIp = attributes[SemanticAttributes.NET_PEER_IP];
    if (peerService) {
        return String(peerService);
    }
    else if (httpHost) {
        return String(httpHost);
    }
    else if (httpUrl) {
        return String(httpUrl);
    }
    else if (netPeerName) {
        return String(netPeerName);
    }
    else if (netPeerIp) {
        return String(netPeerIp);
    }
    return "";
}
export function isExceptionTelemetry(logRecord) {
    const baseType = logRecord.attributes["_MS.baseType"];
    // If Application Insights Legacy logs
    if (baseType && baseType === "ExceptionData") {
        return true;
    }
    else if (logRecord.attributes[SemanticAttributes.EXCEPTION_MESSAGE] ||
        logRecord.attributes[SemanticAttributes.EXCEPTION_TYPE]) {
        return true;
    }
    return false;
}
export function isTraceTelemetry(logRecord) {
    const baseType = logRecord.attributes["_MS.baseType"];
    // If Application Insights Legacy logs
    if (baseType && baseType === "MessageData") {
        return true;
    }
    else if (!logRecord.attributes[SemanticAttributes.EXCEPTION_MESSAGE] &&
        !logRecord.attributes[SemanticAttributes.EXCEPTION_TYPE]) {
        return true;
    }
    return false;
}
export function isSyntheticLoad(record) {
    const userAgent = String(record.attributes[SemanticAttributes.HTTP_USER_AGENT]);
    return userAgent !== null && userAgent.includes("AlwaysOn") ? true : false;
}
export function convertDimensions(dimensions) {
    let convertedDimensions = {};
    for (let dim in dimensions) {
        convertedDimensions[StandardMetricPropertyNames[dim]] = dimensions[dim];
    }
    return convertedDimensions;
}
//# sourceMappingURL=utils.js.map